// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ncc.proto

#ifndef PROTOBUF_ncc_2eproto__INCLUDED
#define PROTOBUF_ncc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ncc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ncc_2eproto();
void protobuf_AssignDesc_ncc_2eproto();
void protobuf_ShutdownFile_ncc_2eproto();

class VocabWord;
class DocTokEnt;
class TrainWork;
class PhraseInstance;
class Config;
class ModelParts;

enum TokenKind {
  Null = 0,
  Token = 1,
  Entity = 2,
  Phrase = 3,
  Type = 4,
  Hyp = 5
};
bool TokenKind_IsValid(int value);
const TokenKind TokenKind_MIN = Null;
const TokenKind TokenKind_MAX = Hyp;
const int TokenKind_ARRAYSIZE = TokenKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TokenKind_descriptor();
inline const ::std::string& TokenKind_Name(TokenKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TokenKind_descriptor(), value);
}
inline bool TokenKind_Parse(
    const ::std::string& name, TokenKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TokenKind>(
    TokenKind_descriptor(), name, value);
}
// ===================================================================

class VocabWord : public ::google::protobuf::Message {
 public:
  VocabWord();
  virtual ~VocabWord();

  VocabWord(const VocabWord& from);

  inline VocabWord& operator=(const VocabWord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VocabWord& default_instance();

  void Swap(VocabWord* other);

  // implements Message ----------------------------------------------

  VocabWord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VocabWord& from);
  void MergeFrom(const VocabWord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string word = 1;
  inline bool has_word() const;
  inline void clear_word();
  static const int kWordFieldNumber = 1;
  inline const ::std::string& word() const;
  inline void set_word(const ::std::string& value);
  inline void set_word(const char* value);
  inline void set_word(const char* value, size_t size);
  inline ::std::string* mutable_word();
  inline ::std::string* release_word();
  inline void set_allocated_word(::std::string* word);

  // optional int32 wid = 2;
  inline bool has_wid() const;
  inline void clear_wid();
  static const int kWidFieldNumber = 2;
  inline ::google::protobuf::int32 wid() const;
  inline void set_wid(::google::protobuf::int32 value);

  // optional float count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline float count() const;
  inline void set_count(float value);

  // optional int32 slots = 4;
  inline bool has_slots() const;
  inline void clear_slots();
  static const int kSlotsFieldNumber = 4;
  inline ::google::protobuf::int32 slots() const;
  inline void set_slots(::google::protobuf::int32 value);

  // optional .ncc.TokenKind kind = 5;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 5;
  inline ::ncc::TokenKind kind() const;
  inline void set_kind(::ncc::TokenKind value);

  // repeated string hypernyms = 6;
  inline int hypernyms_size() const;
  inline void clear_hypernyms();
  static const int kHypernymsFieldNumber = 6;
  inline const ::std::string& hypernyms(int index) const;
  inline ::std::string* mutable_hypernyms(int index);
  inline void set_hypernyms(int index, const ::std::string& value);
  inline void set_hypernyms(int index, const char* value);
  inline void set_hypernyms(int index, const char* value, size_t size);
  inline ::std::string* add_hypernyms();
  inline void add_hypernyms(const ::std::string& value);
  inline void add_hypernyms(const char* value);
  inline void add_hypernyms(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hypernyms() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hypernyms();

  // @@protoc_insertion_point(class_scope:ncc.VocabWord)
 private:
  inline void set_has_word();
  inline void clear_has_word();
  inline void set_has_wid();
  inline void clear_has_wid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_slots();
  inline void clear_has_slots();
  inline void set_has_kind();
  inline void clear_has_kind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* word_;
  ::google::protobuf::int32 wid_;
  float count_;
  ::google::protobuf::int32 slots_;
  int kind_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hypernyms_;
  friend void  protobuf_AddDesc_ncc_2eproto();
  friend void protobuf_AssignDesc_ncc_2eproto();
  friend void protobuf_ShutdownFile_ncc_2eproto();

  void InitAsDefaultInstance();
  static VocabWord* default_instance_;
};
// -------------------------------------------------------------------

class DocTokEnt : public ::google::protobuf::Message {
 public:
  DocTokEnt();
  virtual ~DocTokEnt();

  DocTokEnt(const DocTokEnt& from);

  inline DocTokEnt& operator=(const DocTokEnt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocTokEnt& default_instance();

  void Swap(DocTokEnt* other);

  // implements Message ----------------------------------------------

  DocTokEnt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocTokEnt& from);
  void MergeFrom(const DocTokEnt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string docid = 1;
  inline bool has_docid() const;
  inline void clear_docid();
  static const int kDocidFieldNumber = 1;
  inline const ::std::string& docid() const;
  inline void set_docid(const ::std::string& value);
  inline void set_docid(const char* value);
  inline void set_docid(const char* value, size_t size);
  inline ::std::string* mutable_docid();
  inline ::std::string* release_docid();
  inline void set_allocated_docid(::std::string* docid);

  // repeated int32 tok_ids = 2 [packed = true];
  inline int tok_ids_size() const;
  inline void clear_tok_ids();
  static const int kTokIdsFieldNumber = 2;
  inline ::google::protobuf::int32 tok_ids(int index) const;
  inline void set_tok_ids(int index, ::google::protobuf::int32 value);
  inline void add_tok_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tok_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tok_ids();

  // repeated int32 ent_begins = 3 [packed = true];
  inline int ent_begins_size() const;
  inline void clear_ent_begins();
  static const int kEntBeginsFieldNumber = 3;
  inline ::google::protobuf::int32 ent_begins(int index) const;
  inline void set_ent_begins(int index, ::google::protobuf::int32 value);
  inline void add_ent_begins(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ent_begins() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ent_begins();

  // repeated int32 ent_ends = 4 [packed = true];
  inline int ent_ends_size() const;
  inline void clear_ent_ends();
  static const int kEntEndsFieldNumber = 4;
  inline ::google::protobuf::int32 ent_ends(int index) const;
  inline void set_ent_ends(int index, ::google::protobuf::int32 value);
  inline void add_ent_ends(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ent_ends() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ent_ends();

  // repeated int32 ent_ids = 5 [packed = true];
  inline int ent_ids_size() const;
  inline void clear_ent_ids();
  static const int kEntIdsFieldNumber = 5;
  inline ::google::protobuf::int32 ent_ids(int index) const;
  inline void set_ent_ids(int index, ::google::protobuf::int32 value);
  inline void add_ent_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ent_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ent_ids();

  // @@protoc_insertion_point(class_scope:ncc.DocTokEnt)
 private:
  inline void set_has_docid();
  inline void clear_has_docid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* docid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tok_ids_;
  mutable int _tok_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ent_begins_;
  mutable int _ent_begins_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ent_ends_;
  mutable int _ent_ends_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ent_ids_;
  mutable int _ent_ids_cached_byte_size_;
  friend void  protobuf_AddDesc_ncc_2eproto();
  friend void protobuf_AssignDesc_ncc_2eproto();
  friend void protobuf_ShutdownFile_ncc_2eproto();

  void InitAsDefaultInstance();
  static DocTokEnt* default_instance_;
};
// -------------------------------------------------------------------

class TrainWork : public ::google::protobuf::Message {
 public:
  TrainWork();
  virtual ~TrainWork();

  TrainWork(const TrainWork& from);

  inline TrainWork& operator=(const TrainWork& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrainWork& default_instance();

  void Swap(TrainWork* other);

  // implements Message ----------------------------------------------

  TrainWork* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrainWork& from);
  void MergeFrom(const TrainWork& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 focus_tid = 1;
  inline bool has_focus_tid() const;
  inline void clear_focus_tid();
  static const int kFocusTidFieldNumber = 1;
  inline ::google::protobuf::int32 focus_tid() const;
  inline void set_focus_tid(::google::protobuf::int32 value);

  // optional .ncc.TokenKind focus_kind = 2;
  inline bool has_focus_kind() const;
  inline void clear_focus_kind();
  static const int kFocusKindFieldNumber = 2;
  inline ::ncc::TokenKind focus_kind() const;
  inline void set_focus_kind(::ncc::TokenKind value);

  // repeated int32 context_tids = 3 [packed = true];
  inline int context_tids_size() const;
  inline void clear_context_tids();
  static const int kContextTidsFieldNumber = 3;
  inline ::google::protobuf::int32 context_tids(int index) const;
  inline void set_context_tids(int index, ::google::protobuf::int32 value);
  inline void add_context_tids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      context_tids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_context_tids();

  // repeated .ncc.TokenKind context_kinds = 4 [packed = true];
  inline int context_kinds_size() const;
  inline void clear_context_kinds();
  static const int kContextKindsFieldNumber = 4;
  inline ::ncc::TokenKind context_kinds(int index) const;
  inline void set_context_kinds(int index, ::ncc::TokenKind value);
  inline void add_context_kinds(::ncc::TokenKind value);
  inline const ::google::protobuf::RepeatedField<int>& context_kinds() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_context_kinds();

  // @@protoc_insertion_point(class_scope:ncc.TrainWork)
 private:
  inline void set_has_focus_tid();
  inline void clear_has_focus_tid();
  inline void set_has_focus_kind();
  inline void clear_has_focus_kind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 focus_tid_;
  int focus_kind_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > context_tids_;
  mutable int _context_tids_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> context_kinds_;
  mutable int _context_kinds_cached_byte_size_;
  friend void  protobuf_AddDesc_ncc_2eproto();
  friend void protobuf_AssignDesc_ncc_2eproto();
  friend void protobuf_ShutdownFile_ncc_2eproto();

  void InitAsDefaultInstance();
  static TrainWork* default_instance_;
};
// -------------------------------------------------------------------

class PhraseInstance : public ::google::protobuf::Message {
 public:
  PhraseInstance();
  virtual ~PhraseInstance();

  PhraseInstance(const PhraseInstance& from);

  inline PhraseInstance& operator=(const PhraseInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhraseInstance& default_instance();

  void Swap(PhraseInstance* other);

  // implements Message ----------------------------------------------

  PhraseInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PhraseInstance& from);
  void MergeFrom(const PhraseInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string th_label = 1;
  inline bool has_th_label() const;
  inline void clear_th_label();
  static const int kThLabelFieldNumber = 1;
  inline const ::std::string& th_label() const;
  inline void set_th_label(const ::std::string& value);
  inline void set_th_label(const char* value);
  inline void set_th_label(const char* value, size_t size);
  inline ::std::string* mutable_th_label();
  inline ::std::string* release_th_label();
  inline void set_allocated_th_label(::std::string* th_label);

  // optional float noncomp_label = 2;
  inline bool has_noncomp_label() const;
  inline void clear_noncomp_label();
  static const int kNoncompLabelFieldNumber = 2;
  inline float noncomp_label() const;
  inline void set_noncomp_label(float value);

  // optional int32 phrase_wid = 3;
  inline bool has_phrase_wid() const;
  inline void clear_phrase_wid();
  static const int kPhraseWidFieldNumber = 3;
  inline ::google::protobuf::int32 phrase_wid() const;
  inline void set_phrase_wid(::google::protobuf::int32 value);

  // repeated int32 word_wids = 4;
  inline int word_wids_size() const;
  inline void clear_word_wids();
  static const int kWordWidsFieldNumber = 4;
  inline ::google::protobuf::int32 word_wids(int index) const;
  inline void set_word_wids(int index, ::google::protobuf::int32 value);
  inline void add_word_wids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      word_wids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_word_wids();

  // @@protoc_insertion_point(class_scope:ncc.PhraseInstance)
 private:
  inline void set_has_th_label();
  inline void clear_has_th_label();
  inline void set_has_noncomp_label();
  inline void clear_has_noncomp_label();
  inline void set_has_phrase_wid();
  inline void clear_has_phrase_wid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* th_label_;
  float noncomp_label_;
  ::google::protobuf::int32 phrase_wid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > word_wids_;
  friend void  protobuf_AddDesc_ncc_2eproto();
  friend void protobuf_AssignDesc_ncc_2eproto();
  friend void protobuf_ShutdownFile_ncc_2eproto();

  void InitAsDefaultInstance();
  static PhraseInstance* default_instance_;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float unipower = 1 [default = 0.75];
  inline bool has_unipower() const;
  inline void clear_unipower();
  static const int kUnipowerFieldNumber = 1;
  inline float unipower() const;
  inline void set_unipower(float value);

  // required int32 dim = 2 [default = 100];
  inline bool has_dim() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 2;
  inline ::google::protobuf::int32 dim() const;
  inline void set_dim(::google::protobuf::int32 value);

  // required int32 window = 3 [default = 5];
  inline bool has_window() const;
  inline void clear_window();
  static const int kWindowFieldNumber = 3;
  inline ::google::protobuf::int32 window() const;
  inline void set_window(::google::protobuf::int32 value);

  // required int32 neg = 4 [default = 5];
  inline bool has_neg() const;
  inline void clear_neg();
  static const int kNegFieldNumber = 4;
  inline ::google::protobuf::int32 neg() const;
  inline void set_neg(::google::protobuf::int32 value);

  // required float step = 5 [default = 0.025];
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 5;
  inline float step() const;
  inline void set_step(float value);

  // required int32 epochs = 6 [default = 1];
  inline bool has_epochs() const;
  inline void clear_epochs();
  static const int kEpochsFieldNumber = 6;
  inline ::google::protobuf::int32 epochs() const;
  inline void set_epochs(::google::protobuf::int32 value);

  // required int32 slots = 7 [default = 100000000];
  inline bool has_slots() const;
  inline void clear_slots();
  static const int kSlotsFieldNumber = 7;
  inline ::google::protobuf::int32 slots() const;
  inline void set_slots(::google::protobuf::int32 value);

  // required int32 debug = 999 [default = 0];
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 999;
  inline ::google::protobuf::int32 debug() const;
  inline void set_debug(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ncc.Config)
 private:
  inline void set_has_unipower();
  inline void clear_has_unipower();
  inline void set_has_dim();
  inline void clear_has_dim();
  inline void set_has_window();
  inline void clear_has_window();
  inline void set_has_neg();
  inline void clear_has_neg();
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_epochs();
  inline void clear_has_epochs();
  inline void set_has_slots();
  inline void clear_has_slots();
  inline void set_has_debug();
  inline void clear_has_debug();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float unipower_;
  ::google::protobuf::int32 dim_;
  ::google::protobuf::int32 window_;
  ::google::protobuf::int32 neg_;
  float step_;
  ::google::protobuf::int32 epochs_;
  ::google::protobuf::int32 slots_;
  ::google::protobuf::int32 debug_;
  friend void  protobuf_AddDesc_ncc_2eproto();
  friend void protobuf_AssignDesc_ncc_2eproto();
  friend void protobuf_ShutdownFile_ncc_2eproto();

  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// -------------------------------------------------------------------

class ModelParts : public ::google::protobuf::Message {
 public:
  ModelParts();
  virtual ~ModelParts();

  ModelParts(const ModelParts& from);

  inline ModelParts& operator=(const ModelParts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelParts& default_instance();

  void Swap(ModelParts* other);

  // implements Message ----------------------------------------------

  ModelParts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelParts& from);
  void MergeFrom(const ModelParts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float radius = 1;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 1;
  inline float radius() const;
  inline void set_radius(float value);

  // @@protoc_insertion_point(class_scope:ncc.ModelParts)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float radius_;
  friend void  protobuf_AddDesc_ncc_2eproto();
  friend void protobuf_AssignDesc_ncc_2eproto();
  friend void protobuf_ShutdownFile_ncc_2eproto();

  void InitAsDefaultInstance();
  static ModelParts* default_instance_;
};
// ===================================================================


// ===================================================================

// VocabWord

// optional string word = 1;
inline bool VocabWord::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VocabWord::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VocabWord::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VocabWord::clear_word() {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_->clear();
  }
  clear_has_word();
}
inline const ::std::string& VocabWord::word() const {
  // @@protoc_insertion_point(field_get:ncc.VocabWord.word)
  return *word_;
}
inline void VocabWord::set_word(const ::std::string& value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set:ncc.VocabWord.word)
}
inline void VocabWord::set_word(const char* value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set_char:ncc.VocabWord.word)
}
inline void VocabWord::set_word(const char* value, size_t size) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ncc.VocabWord.word)
}
inline ::std::string* VocabWord::mutable_word() {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ncc.VocabWord.word)
  return word_;
}
inline ::std::string* VocabWord::release_word() {
  clear_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = word_;
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VocabWord::set_allocated_word(::std::string* word) {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete word_;
  }
  if (word) {
    set_has_word();
    word_ = word;
  } else {
    clear_has_word();
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ncc.VocabWord.word)
}

// optional int32 wid = 2;
inline bool VocabWord::has_wid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VocabWord::set_has_wid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VocabWord::clear_has_wid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VocabWord::clear_wid() {
  wid_ = 0;
  clear_has_wid();
}
inline ::google::protobuf::int32 VocabWord::wid() const {
  // @@protoc_insertion_point(field_get:ncc.VocabWord.wid)
  return wid_;
}
inline void VocabWord::set_wid(::google::protobuf::int32 value) {
  set_has_wid();
  wid_ = value;
  // @@protoc_insertion_point(field_set:ncc.VocabWord.wid)
}

// optional float count = 3;
inline bool VocabWord::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VocabWord::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VocabWord::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VocabWord::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline float VocabWord::count() const {
  // @@protoc_insertion_point(field_get:ncc.VocabWord.count)
  return count_;
}
inline void VocabWord::set_count(float value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:ncc.VocabWord.count)
}

// optional int32 slots = 4;
inline bool VocabWord::has_slots() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VocabWord::set_has_slots() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VocabWord::clear_has_slots() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VocabWord::clear_slots() {
  slots_ = 0;
  clear_has_slots();
}
inline ::google::protobuf::int32 VocabWord::slots() const {
  // @@protoc_insertion_point(field_get:ncc.VocabWord.slots)
  return slots_;
}
inline void VocabWord::set_slots(::google::protobuf::int32 value) {
  set_has_slots();
  slots_ = value;
  // @@protoc_insertion_point(field_set:ncc.VocabWord.slots)
}

// optional .ncc.TokenKind kind = 5;
inline bool VocabWord::has_kind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VocabWord::set_has_kind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VocabWord::clear_has_kind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VocabWord::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::ncc::TokenKind VocabWord::kind() const {
  // @@protoc_insertion_point(field_get:ncc.VocabWord.kind)
  return static_cast< ::ncc::TokenKind >(kind_);
}
inline void VocabWord::set_kind(::ncc::TokenKind value) {
  assert(::ncc::TokenKind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:ncc.VocabWord.kind)
}

// repeated string hypernyms = 6;
inline int VocabWord::hypernyms_size() const {
  return hypernyms_.size();
}
inline void VocabWord::clear_hypernyms() {
  hypernyms_.Clear();
}
inline const ::std::string& VocabWord::hypernyms(int index) const {
  // @@protoc_insertion_point(field_get:ncc.VocabWord.hypernyms)
  return hypernyms_.Get(index);
}
inline ::std::string* VocabWord::mutable_hypernyms(int index) {
  // @@protoc_insertion_point(field_mutable:ncc.VocabWord.hypernyms)
  return hypernyms_.Mutable(index);
}
inline void VocabWord::set_hypernyms(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ncc.VocabWord.hypernyms)
  hypernyms_.Mutable(index)->assign(value);
}
inline void VocabWord::set_hypernyms(int index, const char* value) {
  hypernyms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ncc.VocabWord.hypernyms)
}
inline void VocabWord::set_hypernyms(int index, const char* value, size_t size) {
  hypernyms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ncc.VocabWord.hypernyms)
}
inline ::std::string* VocabWord::add_hypernyms() {
  return hypernyms_.Add();
}
inline void VocabWord::add_hypernyms(const ::std::string& value) {
  hypernyms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ncc.VocabWord.hypernyms)
}
inline void VocabWord::add_hypernyms(const char* value) {
  hypernyms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ncc.VocabWord.hypernyms)
}
inline void VocabWord::add_hypernyms(const char* value, size_t size) {
  hypernyms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ncc.VocabWord.hypernyms)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VocabWord::hypernyms() const {
  // @@protoc_insertion_point(field_list:ncc.VocabWord.hypernyms)
  return hypernyms_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VocabWord::mutable_hypernyms() {
  // @@protoc_insertion_point(field_mutable_list:ncc.VocabWord.hypernyms)
  return &hypernyms_;
}

// -------------------------------------------------------------------

// DocTokEnt

// optional string docid = 1;
inline bool DocTokEnt::has_docid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocTokEnt::set_has_docid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocTokEnt::clear_has_docid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocTokEnt::clear_docid() {
  if (docid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docid_->clear();
  }
  clear_has_docid();
}
inline const ::std::string& DocTokEnt::docid() const {
  // @@protoc_insertion_point(field_get:ncc.DocTokEnt.docid)
  return *docid_;
}
inline void DocTokEnt::set_docid(const ::std::string& value) {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docid_ = new ::std::string;
  }
  docid_->assign(value);
  // @@protoc_insertion_point(field_set:ncc.DocTokEnt.docid)
}
inline void DocTokEnt::set_docid(const char* value) {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docid_ = new ::std::string;
  }
  docid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ncc.DocTokEnt.docid)
}
inline void DocTokEnt::set_docid(const char* value, size_t size) {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docid_ = new ::std::string;
  }
  docid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ncc.DocTokEnt.docid)
}
inline ::std::string* DocTokEnt::mutable_docid() {
  set_has_docid();
  if (docid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    docid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ncc.DocTokEnt.docid)
  return docid_;
}
inline ::std::string* DocTokEnt::release_docid() {
  clear_has_docid();
  if (docid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = docid_;
    docid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocTokEnt::set_allocated_docid(::std::string* docid) {
  if (docid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete docid_;
  }
  if (docid) {
    set_has_docid();
    docid_ = docid;
  } else {
    clear_has_docid();
    docid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ncc.DocTokEnt.docid)
}

// repeated int32 tok_ids = 2 [packed = true];
inline int DocTokEnt::tok_ids_size() const {
  return tok_ids_.size();
}
inline void DocTokEnt::clear_tok_ids() {
  tok_ids_.Clear();
}
inline ::google::protobuf::int32 DocTokEnt::tok_ids(int index) const {
  // @@protoc_insertion_point(field_get:ncc.DocTokEnt.tok_ids)
  return tok_ids_.Get(index);
}
inline void DocTokEnt::set_tok_ids(int index, ::google::protobuf::int32 value) {
  tok_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ncc.DocTokEnt.tok_ids)
}
inline void DocTokEnt::add_tok_ids(::google::protobuf::int32 value) {
  tok_ids_.Add(value);
  // @@protoc_insertion_point(field_add:ncc.DocTokEnt.tok_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DocTokEnt::tok_ids() const {
  // @@protoc_insertion_point(field_list:ncc.DocTokEnt.tok_ids)
  return tok_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DocTokEnt::mutable_tok_ids() {
  // @@protoc_insertion_point(field_mutable_list:ncc.DocTokEnt.tok_ids)
  return &tok_ids_;
}

// repeated int32 ent_begins = 3 [packed = true];
inline int DocTokEnt::ent_begins_size() const {
  return ent_begins_.size();
}
inline void DocTokEnt::clear_ent_begins() {
  ent_begins_.Clear();
}
inline ::google::protobuf::int32 DocTokEnt::ent_begins(int index) const {
  // @@protoc_insertion_point(field_get:ncc.DocTokEnt.ent_begins)
  return ent_begins_.Get(index);
}
inline void DocTokEnt::set_ent_begins(int index, ::google::protobuf::int32 value) {
  ent_begins_.Set(index, value);
  // @@protoc_insertion_point(field_set:ncc.DocTokEnt.ent_begins)
}
inline void DocTokEnt::add_ent_begins(::google::protobuf::int32 value) {
  ent_begins_.Add(value);
  // @@protoc_insertion_point(field_add:ncc.DocTokEnt.ent_begins)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DocTokEnt::ent_begins() const {
  // @@protoc_insertion_point(field_list:ncc.DocTokEnt.ent_begins)
  return ent_begins_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DocTokEnt::mutable_ent_begins() {
  // @@protoc_insertion_point(field_mutable_list:ncc.DocTokEnt.ent_begins)
  return &ent_begins_;
}

// repeated int32 ent_ends = 4 [packed = true];
inline int DocTokEnt::ent_ends_size() const {
  return ent_ends_.size();
}
inline void DocTokEnt::clear_ent_ends() {
  ent_ends_.Clear();
}
inline ::google::protobuf::int32 DocTokEnt::ent_ends(int index) const {
  // @@protoc_insertion_point(field_get:ncc.DocTokEnt.ent_ends)
  return ent_ends_.Get(index);
}
inline void DocTokEnt::set_ent_ends(int index, ::google::protobuf::int32 value) {
  ent_ends_.Set(index, value);
  // @@protoc_insertion_point(field_set:ncc.DocTokEnt.ent_ends)
}
inline void DocTokEnt::add_ent_ends(::google::protobuf::int32 value) {
  ent_ends_.Add(value);
  // @@protoc_insertion_point(field_add:ncc.DocTokEnt.ent_ends)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DocTokEnt::ent_ends() const {
  // @@protoc_insertion_point(field_list:ncc.DocTokEnt.ent_ends)
  return ent_ends_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DocTokEnt::mutable_ent_ends() {
  // @@protoc_insertion_point(field_mutable_list:ncc.DocTokEnt.ent_ends)
  return &ent_ends_;
}

// repeated int32 ent_ids = 5 [packed = true];
inline int DocTokEnt::ent_ids_size() const {
  return ent_ids_.size();
}
inline void DocTokEnt::clear_ent_ids() {
  ent_ids_.Clear();
}
inline ::google::protobuf::int32 DocTokEnt::ent_ids(int index) const {
  // @@protoc_insertion_point(field_get:ncc.DocTokEnt.ent_ids)
  return ent_ids_.Get(index);
}
inline void DocTokEnt::set_ent_ids(int index, ::google::protobuf::int32 value) {
  ent_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ncc.DocTokEnt.ent_ids)
}
inline void DocTokEnt::add_ent_ids(::google::protobuf::int32 value) {
  ent_ids_.Add(value);
  // @@protoc_insertion_point(field_add:ncc.DocTokEnt.ent_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DocTokEnt::ent_ids() const {
  // @@protoc_insertion_point(field_list:ncc.DocTokEnt.ent_ids)
  return ent_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DocTokEnt::mutable_ent_ids() {
  // @@protoc_insertion_point(field_mutable_list:ncc.DocTokEnt.ent_ids)
  return &ent_ids_;
}

// -------------------------------------------------------------------

// TrainWork

// optional int32 focus_tid = 1;
inline bool TrainWork::has_focus_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainWork::set_has_focus_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainWork::clear_has_focus_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainWork::clear_focus_tid() {
  focus_tid_ = 0;
  clear_has_focus_tid();
}
inline ::google::protobuf::int32 TrainWork::focus_tid() const {
  // @@protoc_insertion_point(field_get:ncc.TrainWork.focus_tid)
  return focus_tid_;
}
inline void TrainWork::set_focus_tid(::google::protobuf::int32 value) {
  set_has_focus_tid();
  focus_tid_ = value;
  // @@protoc_insertion_point(field_set:ncc.TrainWork.focus_tid)
}

// optional .ncc.TokenKind focus_kind = 2;
inline bool TrainWork::has_focus_kind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainWork::set_has_focus_kind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainWork::clear_has_focus_kind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainWork::clear_focus_kind() {
  focus_kind_ = 0;
  clear_has_focus_kind();
}
inline ::ncc::TokenKind TrainWork::focus_kind() const {
  // @@protoc_insertion_point(field_get:ncc.TrainWork.focus_kind)
  return static_cast< ::ncc::TokenKind >(focus_kind_);
}
inline void TrainWork::set_focus_kind(::ncc::TokenKind value) {
  assert(::ncc::TokenKind_IsValid(value));
  set_has_focus_kind();
  focus_kind_ = value;
  // @@protoc_insertion_point(field_set:ncc.TrainWork.focus_kind)
}

// repeated int32 context_tids = 3 [packed = true];
inline int TrainWork::context_tids_size() const {
  return context_tids_.size();
}
inline void TrainWork::clear_context_tids() {
  context_tids_.Clear();
}
inline ::google::protobuf::int32 TrainWork::context_tids(int index) const {
  // @@protoc_insertion_point(field_get:ncc.TrainWork.context_tids)
  return context_tids_.Get(index);
}
inline void TrainWork::set_context_tids(int index, ::google::protobuf::int32 value) {
  context_tids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ncc.TrainWork.context_tids)
}
inline void TrainWork::add_context_tids(::google::protobuf::int32 value) {
  context_tids_.Add(value);
  // @@protoc_insertion_point(field_add:ncc.TrainWork.context_tids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TrainWork::context_tids() const {
  // @@protoc_insertion_point(field_list:ncc.TrainWork.context_tids)
  return context_tids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TrainWork::mutable_context_tids() {
  // @@protoc_insertion_point(field_mutable_list:ncc.TrainWork.context_tids)
  return &context_tids_;
}

// repeated .ncc.TokenKind context_kinds = 4 [packed = true];
inline int TrainWork::context_kinds_size() const {
  return context_kinds_.size();
}
inline void TrainWork::clear_context_kinds() {
  context_kinds_.Clear();
}
inline ::ncc::TokenKind TrainWork::context_kinds(int index) const {
  // @@protoc_insertion_point(field_get:ncc.TrainWork.context_kinds)
  return static_cast< ::ncc::TokenKind >(context_kinds_.Get(index));
}
inline void TrainWork::set_context_kinds(int index, ::ncc::TokenKind value) {
  assert(::ncc::TokenKind_IsValid(value));
  context_kinds_.Set(index, value);
  // @@protoc_insertion_point(field_set:ncc.TrainWork.context_kinds)
}
inline void TrainWork::add_context_kinds(::ncc::TokenKind value) {
  assert(::ncc::TokenKind_IsValid(value));
  context_kinds_.Add(value);
  // @@protoc_insertion_point(field_add:ncc.TrainWork.context_kinds)
}
inline const ::google::protobuf::RepeatedField<int>&
TrainWork::context_kinds() const {
  // @@protoc_insertion_point(field_list:ncc.TrainWork.context_kinds)
  return context_kinds_;
}
inline ::google::protobuf::RepeatedField<int>*
TrainWork::mutable_context_kinds() {
  // @@protoc_insertion_point(field_mutable_list:ncc.TrainWork.context_kinds)
  return &context_kinds_;
}

// -------------------------------------------------------------------

// PhraseInstance

// optional string th_label = 1;
inline bool PhraseInstance::has_th_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhraseInstance::set_has_th_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhraseInstance::clear_has_th_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhraseInstance::clear_th_label() {
  if (th_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    th_label_->clear();
  }
  clear_has_th_label();
}
inline const ::std::string& PhraseInstance::th_label() const {
  // @@protoc_insertion_point(field_get:ncc.PhraseInstance.th_label)
  return *th_label_;
}
inline void PhraseInstance::set_th_label(const ::std::string& value) {
  set_has_th_label();
  if (th_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    th_label_ = new ::std::string;
  }
  th_label_->assign(value);
  // @@protoc_insertion_point(field_set:ncc.PhraseInstance.th_label)
}
inline void PhraseInstance::set_th_label(const char* value) {
  set_has_th_label();
  if (th_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    th_label_ = new ::std::string;
  }
  th_label_->assign(value);
  // @@protoc_insertion_point(field_set_char:ncc.PhraseInstance.th_label)
}
inline void PhraseInstance::set_th_label(const char* value, size_t size) {
  set_has_th_label();
  if (th_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    th_label_ = new ::std::string;
  }
  th_label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ncc.PhraseInstance.th_label)
}
inline ::std::string* PhraseInstance::mutable_th_label() {
  set_has_th_label();
  if (th_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    th_label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ncc.PhraseInstance.th_label)
  return th_label_;
}
inline ::std::string* PhraseInstance::release_th_label() {
  clear_has_th_label();
  if (th_label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = th_label_;
    th_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PhraseInstance::set_allocated_th_label(::std::string* th_label) {
  if (th_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete th_label_;
  }
  if (th_label) {
    set_has_th_label();
    th_label_ = th_label;
  } else {
    clear_has_th_label();
    th_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ncc.PhraseInstance.th_label)
}

// optional float noncomp_label = 2;
inline bool PhraseInstance::has_noncomp_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhraseInstance::set_has_noncomp_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhraseInstance::clear_has_noncomp_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhraseInstance::clear_noncomp_label() {
  noncomp_label_ = 0;
  clear_has_noncomp_label();
}
inline float PhraseInstance::noncomp_label() const {
  // @@protoc_insertion_point(field_get:ncc.PhraseInstance.noncomp_label)
  return noncomp_label_;
}
inline void PhraseInstance::set_noncomp_label(float value) {
  set_has_noncomp_label();
  noncomp_label_ = value;
  // @@protoc_insertion_point(field_set:ncc.PhraseInstance.noncomp_label)
}

// optional int32 phrase_wid = 3;
inline bool PhraseInstance::has_phrase_wid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhraseInstance::set_has_phrase_wid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhraseInstance::clear_has_phrase_wid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhraseInstance::clear_phrase_wid() {
  phrase_wid_ = 0;
  clear_has_phrase_wid();
}
inline ::google::protobuf::int32 PhraseInstance::phrase_wid() const {
  // @@protoc_insertion_point(field_get:ncc.PhraseInstance.phrase_wid)
  return phrase_wid_;
}
inline void PhraseInstance::set_phrase_wid(::google::protobuf::int32 value) {
  set_has_phrase_wid();
  phrase_wid_ = value;
  // @@protoc_insertion_point(field_set:ncc.PhraseInstance.phrase_wid)
}

// repeated int32 word_wids = 4;
inline int PhraseInstance::word_wids_size() const {
  return word_wids_.size();
}
inline void PhraseInstance::clear_word_wids() {
  word_wids_.Clear();
}
inline ::google::protobuf::int32 PhraseInstance::word_wids(int index) const {
  // @@protoc_insertion_point(field_get:ncc.PhraseInstance.word_wids)
  return word_wids_.Get(index);
}
inline void PhraseInstance::set_word_wids(int index, ::google::protobuf::int32 value) {
  word_wids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ncc.PhraseInstance.word_wids)
}
inline void PhraseInstance::add_word_wids(::google::protobuf::int32 value) {
  word_wids_.Add(value);
  // @@protoc_insertion_point(field_add:ncc.PhraseInstance.word_wids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PhraseInstance::word_wids() const {
  // @@protoc_insertion_point(field_list:ncc.PhraseInstance.word_wids)
  return word_wids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PhraseInstance::mutable_word_wids() {
  // @@protoc_insertion_point(field_mutable_list:ncc.PhraseInstance.word_wids)
  return &word_wids_;
}

// -------------------------------------------------------------------

// Config

// required float unipower = 1 [default = 0.75];
inline bool Config::has_unipower() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_unipower() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_unipower() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_unipower() {
  unipower_ = 0.75f;
  clear_has_unipower();
}
inline float Config::unipower() const {
  // @@protoc_insertion_point(field_get:ncc.Config.unipower)
  return unipower_;
}
inline void Config::set_unipower(float value) {
  set_has_unipower();
  unipower_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.unipower)
}

// required int32 dim = 2 [default = 100];
inline bool Config::has_dim() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_dim() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_dim() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_dim() {
  dim_ = 100;
  clear_has_dim();
}
inline ::google::protobuf::int32 Config::dim() const {
  // @@protoc_insertion_point(field_get:ncc.Config.dim)
  return dim_;
}
inline void Config::set_dim(::google::protobuf::int32 value) {
  set_has_dim();
  dim_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.dim)
}

// required int32 window = 3 [default = 5];
inline bool Config::has_window() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_window() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_window() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_window() {
  window_ = 5;
  clear_has_window();
}
inline ::google::protobuf::int32 Config::window() const {
  // @@protoc_insertion_point(field_get:ncc.Config.window)
  return window_;
}
inline void Config::set_window(::google::protobuf::int32 value) {
  set_has_window();
  window_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.window)
}

// required int32 neg = 4 [default = 5];
inline bool Config::has_neg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_neg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_neg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_neg() {
  neg_ = 5;
  clear_has_neg();
}
inline ::google::protobuf::int32 Config::neg() const {
  // @@protoc_insertion_point(field_get:ncc.Config.neg)
  return neg_;
}
inline void Config::set_neg(::google::protobuf::int32 value) {
  set_has_neg();
  neg_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.neg)
}

// required float step = 5 [default = 0.025];
inline bool Config::has_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_step() {
  step_ = 0.025f;
  clear_has_step();
}
inline float Config::step() const {
  // @@protoc_insertion_point(field_get:ncc.Config.step)
  return step_;
}
inline void Config::set_step(float value) {
  set_has_step();
  step_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.step)
}

// required int32 epochs = 6 [default = 1];
inline bool Config::has_epochs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_epochs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_epochs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_epochs() {
  epochs_ = 1;
  clear_has_epochs();
}
inline ::google::protobuf::int32 Config::epochs() const {
  // @@protoc_insertion_point(field_get:ncc.Config.epochs)
  return epochs_;
}
inline void Config::set_epochs(::google::protobuf::int32 value) {
  set_has_epochs();
  epochs_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.epochs)
}

// required int32 slots = 7 [default = 100000000];
inline bool Config::has_slots() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Config::set_has_slots() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Config::clear_has_slots() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Config::clear_slots() {
  slots_ = 100000000;
  clear_has_slots();
}
inline ::google::protobuf::int32 Config::slots() const {
  // @@protoc_insertion_point(field_get:ncc.Config.slots)
  return slots_;
}
inline void Config::set_slots(::google::protobuf::int32 value) {
  set_has_slots();
  slots_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.slots)
}

// required int32 debug = 999 [default = 0];
inline bool Config::has_debug() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Config::set_has_debug() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Config::clear_has_debug() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Config::clear_debug() {
  debug_ = 0;
  clear_has_debug();
}
inline ::google::protobuf::int32 Config::debug() const {
  // @@protoc_insertion_point(field_get:ncc.Config.debug)
  return debug_;
}
inline void Config::set_debug(::google::protobuf::int32 value) {
  set_has_debug();
  debug_ = value;
  // @@protoc_insertion_point(field_set:ncc.Config.debug)
}

// -------------------------------------------------------------------

// ModelParts

// optional float radius = 1;
inline bool ModelParts::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelParts::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelParts::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelParts::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float ModelParts::radius() const {
  // @@protoc_insertion_point(field_get:ncc.ModelParts.radius)
  return radius_;
}
inline void ModelParts::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:ncc.ModelParts.radius)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ncc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ncc::TokenKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ncc::TokenKind>() {
  return ::ncc::TokenKind_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ncc_2eproto__INCLUDED
