// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ncc.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ncc.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ncc {

namespace {

const ::google::protobuf::Descriptor* VocabWord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VocabWord_reflection_ = NULL;
const ::google::protobuf::Descriptor* DocTokEnt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DocTokEnt_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrainWork_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrainWork_reflection_ = NULL;
const ::google::protobuf::Descriptor* PhraseInstance_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PhraseInstance_reflection_ = NULL;
const ::google::protobuf::Descriptor* Config_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Config_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelParts_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelParts_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TokenKind_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_ncc_2eproto() {
  protobuf_AddDesc_ncc_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ncc.proto");
  GOOGLE_CHECK(file != NULL);
  VocabWord_descriptor_ = file->message_type(0);
  static const int VocabWord_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, word_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, wid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, slots_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, kind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, hypernyms_),
  };
  VocabWord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VocabWord_descriptor_,
      VocabWord::default_instance_,
      VocabWord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VocabWord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VocabWord));
  DocTokEnt_descriptor_ = file->message_type(1);
  static const int DocTokEnt_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DocTokEnt, docid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DocTokEnt, tok_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DocTokEnt, ent_begins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DocTokEnt, ent_ends_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DocTokEnt, ent_ids_),
  };
  DocTokEnt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DocTokEnt_descriptor_,
      DocTokEnt::default_instance_,
      DocTokEnt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DocTokEnt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DocTokEnt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DocTokEnt));
  TrainWork_descriptor_ = file->message_type(2);
  static const int TrainWork_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainWork, focus_tid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainWork, focus_kind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainWork, context_tids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainWork, context_kinds_),
  };
  TrainWork_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TrainWork_descriptor_,
      TrainWork::default_instance_,
      TrainWork_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainWork, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrainWork, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TrainWork));
  PhraseInstance_descriptor_ = file->message_type(3);
  static const int PhraseInstance_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhraseInstance, th_label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhraseInstance, noncomp_label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhraseInstance, phrase_wid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhraseInstance, word_wids_),
  };
  PhraseInstance_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PhraseInstance_descriptor_,
      PhraseInstance::default_instance_,
      PhraseInstance_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhraseInstance, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PhraseInstance, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PhraseInstance));
  Config_descriptor_ = file->message_type(4);
  static const int Config_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, unipower_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, dim_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, window_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, neg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, epochs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, slots_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, debug_),
  };
  Config_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Config_descriptor_,
      Config::default_instance_,
      Config_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Config));
  ModelParts_descriptor_ = file->message_type(5);
  static const int ModelParts_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelParts, radius_),
  };
  ModelParts_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModelParts_descriptor_,
      ModelParts::default_instance_,
      ModelParts_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelParts, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelParts, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModelParts));
  TokenKind_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ncc_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VocabWord_descriptor_, &VocabWord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DocTokEnt_descriptor_, &DocTokEnt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TrainWork_descriptor_, &TrainWork::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PhraseInstance_descriptor_, &PhraseInstance::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Config_descriptor_, &Config::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModelParts_descriptor_, &ModelParts::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ncc_2eproto() {
  delete VocabWord::default_instance_;
  delete VocabWord_reflection_;
  delete DocTokEnt::default_instance_;
  delete DocTokEnt_reflection_;
  delete TrainWork::default_instance_;
  delete TrainWork_reflection_;
  delete PhraseInstance::default_instance_;
  delete PhraseInstance_reflection_;
  delete Config::default_instance_;
  delete Config_reflection_;
  delete ModelParts::default_instance_;
  delete ModelParts_reflection_;
}

void protobuf_AddDesc_ncc_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tncc.proto\022\003ncc\"u\n\tVocabWord\022\014\n\004word\030\001 "
    "\001(\t\022\013\n\003wid\030\002 \001(\005\022\r\n\005count\030\003 \001(\002\022\r\n\005slots"
    "\030\004 \001(\005\022\034\n\004kind\030\005 \001(\0162\016.ncc.TokenKind\022\021\n\t"
    "hypernyms\030\006 \003(\t\"r\n\tDocTokEnt\022\r\n\005docid\030\001 "
    "\001(\t\022\023\n\007tok_ids\030\002 \003(\005B\002\020\001\022\026\n\nent_begins\030\003"
    " \003(\005B\002\020\001\022\024\n\010ent_ends\030\004 \003(\005B\002\020\001\022\023\n\007ent_id"
    "s\030\005 \003(\005B\002\020\001\"\207\001\n\tTrainWork\022\021\n\tfocus_tid\030\001"
    " \001(\005\022\"\n\nfocus_kind\030\002 \001(\0162\016.ncc.TokenKind"
    "\022\030\n\014context_tids\030\003 \003(\005B\002\020\001\022)\n\rcontext_ki"
    "nds\030\004 \003(\0162\016.ncc.TokenKindB\002\020\001\"`\n\016PhraseI"
    "nstance\022\020\n\010th_label\030\001 \001(\t\022\025\n\rnoncomp_lab"
    "el\030\002 \001(\002\022\022\n\nphrase_wid\030\003 \001(\005\022\021\n\tword_wid"
    "s\030\004 \003(\005\"\252\001\n\006Config\022\026\n\010unipower\030\001 \002(\002:\0040."
    "75\022\020\n\003dim\030\002 \002(\005:\003100\022\021\n\006window\030\003 \002(\005:\0015\022"
    "\016\n\003neg\030\004 \002(\005:\0015\022\023\n\004step\030\005 \002(\002:\0050.025\022\021\n\006"
    "epochs\030\006 \002(\005:\0011\022\030\n\005slots\030\007 \002(\005:\t10000000"
    "0\022\021\n\005debug\030\347\007 \002(\005:\0010\"\034\n\nModelParts\022\016\n\006ra"
    "dius\030\001 \001(\002*K\n\tTokenKind\022\010\n\004Null\020\000\022\t\n\005Tok"
    "en\020\001\022\n\n\006Entity\020\002\022\n\n\006Phrase\020\003\022\010\n\004Type\020\004\022\007"
    "\n\003Hyp\020\005", 767);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ncc.proto", &protobuf_RegisterTypes);
  VocabWord::default_instance_ = new VocabWord();
  DocTokEnt::default_instance_ = new DocTokEnt();
  TrainWork::default_instance_ = new TrainWork();
  PhraseInstance::default_instance_ = new PhraseInstance();
  Config::default_instance_ = new Config();
  ModelParts::default_instance_ = new ModelParts();
  VocabWord::default_instance_->InitAsDefaultInstance();
  DocTokEnt::default_instance_->InitAsDefaultInstance();
  TrainWork::default_instance_->InitAsDefaultInstance();
  PhraseInstance::default_instance_->InitAsDefaultInstance();
  Config::default_instance_->InitAsDefaultInstance();
  ModelParts::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ncc_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ncc_2eproto {
  StaticDescriptorInitializer_ncc_2eproto() {
    protobuf_AddDesc_ncc_2eproto();
  }
} static_descriptor_initializer_ncc_2eproto_;
const ::google::protobuf::EnumDescriptor* TokenKind_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TokenKind_descriptor_;
}
bool TokenKind_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int VocabWord::kWordFieldNumber;
const int VocabWord::kWidFieldNumber;
const int VocabWord::kCountFieldNumber;
const int VocabWord::kSlotsFieldNumber;
const int VocabWord::kKindFieldNumber;
const int VocabWord::kHypernymsFieldNumber;
#endif  // !_MSC_VER

VocabWord::VocabWord()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ncc.VocabWord)
}

void VocabWord::InitAsDefaultInstance() {
}

VocabWord::VocabWord(const VocabWord& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ncc.VocabWord)
}

void VocabWord::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  wid_ = 0;
  count_ = 0;
  slots_ = 0;
  kind_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VocabWord::~VocabWord() {
  // @@protoc_insertion_point(destructor:ncc.VocabWord)
  SharedDtor();
}

void VocabWord::SharedDtor() {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete word_;
  }
  if (this != default_instance_) {
  }
}

void VocabWord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VocabWord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VocabWord_descriptor_;
}

const VocabWord& VocabWord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ncc_2eproto();
  return *default_instance_;
}

VocabWord* VocabWord::default_instance_ = NULL;

VocabWord* VocabWord::New() const {
  return new VocabWord;
}

void VocabWord::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VocabWord*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(wid_, kind_);
    if (has_word()) {
      if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        word_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  hypernyms_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VocabWord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ncc.VocabWord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string word = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->word().data(), this->word().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "word");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_wid;
        break;
      }

      // optional int32 wid = 2;
      case 2: {
        if (tag == 16) {
         parse_wid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wid_)));
          set_has_wid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_count;
        break;
      }

      // optional float count = 3;
      case 3: {
        if (tag == 29) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_slots;
        break;
      }

      // optional int32 slots = 4;
      case 4: {
        if (tag == 32) {
         parse_slots:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &slots_)));
          set_has_slots();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_kind;
        break;
      }

      // optional .ncc.TokenKind kind = 5;
      case 5: {
        if (tag == 40) {
         parse_kind:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ncc::TokenKind_IsValid(value)) {
            set_kind(static_cast< ::ncc::TokenKind >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_hypernyms;
        break;
      }

      // repeated string hypernyms = 6;
      case 6: {
        if (tag == 50) {
         parse_hypernyms:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_hypernyms()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hypernyms(this->hypernyms_size() - 1).data(),
            this->hypernyms(this->hypernyms_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hypernyms");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_hypernyms;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ncc.VocabWord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ncc.VocabWord)
  return false;
#undef DO_
}

void VocabWord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ncc.VocabWord)
  // optional string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "word");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->word(), output);
  }

  // optional int32 wid = 2;
  if (has_wid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->wid(), output);
  }

  // optional float count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->count(), output);
  }

  // optional int32 slots = 4;
  if (has_slots()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->slots(), output);
  }

  // optional .ncc.TokenKind kind = 5;
  if (has_kind()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->kind(), output);
  }

  // repeated string hypernyms = 6;
  for (int i = 0; i < this->hypernyms_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->hypernyms(i).data(), this->hypernyms(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "hypernyms");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->hypernyms(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ncc.VocabWord)
}

::google::protobuf::uint8* VocabWord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ncc.VocabWord)
  // optional string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "word");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->word(), target);
  }

  // optional int32 wid = 2;
  if (has_wid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->wid(), target);
  }

  // optional float count = 3;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->count(), target);
  }

  // optional int32 slots = 4;
  if (has_slots()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->slots(), target);
  }

  // optional .ncc.TokenKind kind = 5;
  if (has_kind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->kind(), target);
  }

  // repeated string hypernyms = 6;
  for (int i = 0; i < this->hypernyms_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hypernyms(i).data(), this->hypernyms(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hypernyms");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(6, this->hypernyms(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ncc.VocabWord)
  return target;
}

int VocabWord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string word = 1;
    if (has_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->word());
    }

    // optional int32 wid = 2;
    if (has_wid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->wid());
    }

    // optional float count = 3;
    if (has_count()) {
      total_size += 1 + 4;
    }

    // optional int32 slots = 4;
    if (has_slots()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->slots());
    }

    // optional .ncc.TokenKind kind = 5;
    if (has_kind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->kind());
    }

  }
  // repeated string hypernyms = 6;
  total_size += 1 * this->hypernyms_size();
  for (int i = 0; i < this->hypernyms_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->hypernyms(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VocabWord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VocabWord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VocabWord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VocabWord::MergeFrom(const VocabWord& from) {
  GOOGLE_CHECK_NE(&from, this);
  hypernyms_.MergeFrom(from.hypernyms_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_word()) {
      set_word(from.word());
    }
    if (from.has_wid()) {
      set_wid(from.wid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_slots()) {
      set_slots(from.slots());
    }
    if (from.has_kind()) {
      set_kind(from.kind());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VocabWord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VocabWord::CopyFrom(const VocabWord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VocabWord::IsInitialized() const {

  return true;
}

void VocabWord::Swap(VocabWord* other) {
  if (other != this) {
    std::swap(word_, other->word_);
    std::swap(wid_, other->wid_);
    std::swap(count_, other->count_);
    std::swap(slots_, other->slots_);
    std::swap(kind_, other->kind_);
    hypernyms_.Swap(&other->hypernyms_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VocabWord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VocabWord_descriptor_;
  metadata.reflection = VocabWord_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DocTokEnt::kDocidFieldNumber;
const int DocTokEnt::kTokIdsFieldNumber;
const int DocTokEnt::kEntBeginsFieldNumber;
const int DocTokEnt::kEntEndsFieldNumber;
const int DocTokEnt::kEntIdsFieldNumber;
#endif  // !_MSC_VER

DocTokEnt::DocTokEnt()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ncc.DocTokEnt)
}

void DocTokEnt::InitAsDefaultInstance() {
}

DocTokEnt::DocTokEnt(const DocTokEnt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ncc.DocTokEnt)
}

void DocTokEnt::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  docid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DocTokEnt::~DocTokEnt() {
  // @@protoc_insertion_point(destructor:ncc.DocTokEnt)
  SharedDtor();
}

void DocTokEnt::SharedDtor() {
  if (docid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete docid_;
  }
  if (this != default_instance_) {
  }
}

void DocTokEnt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DocTokEnt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DocTokEnt_descriptor_;
}

const DocTokEnt& DocTokEnt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ncc_2eproto();
  return *default_instance_;
}

DocTokEnt* DocTokEnt::default_instance_ = NULL;

DocTokEnt* DocTokEnt::New() const {
  return new DocTokEnt;
}

void DocTokEnt::Clear() {
  if (has_docid()) {
    if (docid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      docid_->clear();
    }
  }
  tok_ids_.Clear();
  ent_begins_.Clear();
  ent_ends_.Clear();
  ent_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DocTokEnt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ncc.DocTokEnt)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string docid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_docid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->docid().data(), this->docid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "docid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tok_ids;
        break;
      }

      // repeated int32 tok_ids = 2 [packed = true];
      case 2: {
        if (tag == 18) {
         parse_tok_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_tok_ids())));
        } else if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 18, input, this->mutable_tok_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ent_begins;
        break;
      }

      // repeated int32 ent_begins = 3 [packed = true];
      case 3: {
        if (tag == 26) {
         parse_ent_begins:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_ent_begins())));
        } else if (tag == 24) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 26, input, this->mutable_ent_begins())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ent_ends;
        break;
      }

      // repeated int32 ent_ends = 4 [packed = true];
      case 4: {
        if (tag == 34) {
         parse_ent_ends:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_ent_ends())));
        } else if (tag == 32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 34, input, this->mutable_ent_ends())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ent_ids;
        break;
      }

      // repeated int32 ent_ids = 5 [packed = true];
      case 5: {
        if (tag == 42) {
         parse_ent_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_ent_ids())));
        } else if (tag == 40) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 42, input, this->mutable_ent_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ncc.DocTokEnt)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ncc.DocTokEnt)
  return false;
#undef DO_
}

void DocTokEnt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ncc.DocTokEnt)
  // optional string docid = 1;
  if (has_docid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "docid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->docid(), output);
  }

  // repeated int32 tok_ids = 2 [packed = true];
  if (this->tok_ids_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_tok_ids_cached_byte_size_);
  }
  for (int i = 0; i < this->tok_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->tok_ids(i), output);
  }

  // repeated int32 ent_begins = 3 [packed = true];
  if (this->ent_begins_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_ent_begins_cached_byte_size_);
  }
  for (int i = 0; i < this->ent_begins_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->ent_begins(i), output);
  }

  // repeated int32 ent_ends = 4 [packed = true];
  if (this->ent_ends_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_ent_ends_cached_byte_size_);
  }
  for (int i = 0; i < this->ent_ends_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->ent_ends(i), output);
  }

  // repeated int32 ent_ids = 5 [packed = true];
  if (this->ent_ids_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(5, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_ent_ids_cached_byte_size_);
  }
  for (int i = 0; i < this->ent_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->ent_ids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ncc.DocTokEnt)
}

::google::protobuf::uint8* DocTokEnt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ncc.DocTokEnt)
  // optional string docid = 1;
  if (has_docid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->docid().data(), this->docid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "docid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->docid(), target);
  }

  // repeated int32 tok_ids = 2 [packed = true];
  if (this->tok_ids_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      2,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _tok_ids_cached_byte_size_, target);
  }
  for (int i = 0; i < this->tok_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->tok_ids(i), target);
  }

  // repeated int32 ent_begins = 3 [packed = true];
  if (this->ent_begins_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _ent_begins_cached_byte_size_, target);
  }
  for (int i = 0; i < this->ent_begins_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->ent_begins(i), target);
  }

  // repeated int32 ent_ends = 4 [packed = true];
  if (this->ent_ends_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _ent_ends_cached_byte_size_, target);
  }
  for (int i = 0; i < this->ent_ends_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->ent_ends(i), target);
  }

  // repeated int32 ent_ids = 5 [packed = true];
  if (this->ent_ids_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      5,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _ent_ids_cached_byte_size_, target);
  }
  for (int i = 0; i < this->ent_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->ent_ids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ncc.DocTokEnt)
  return target;
}

int DocTokEnt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string docid = 1;
    if (has_docid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->docid());
    }

  }
  // repeated int32 tok_ids = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->tok_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->tok_ids(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _tok_ids_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 ent_begins = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->ent_begins_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->ent_begins(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _ent_begins_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 ent_ends = 4 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->ent_ends_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->ent_ends(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _ent_ends_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 ent_ids = 5 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->ent_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->ent_ids(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _ent_ids_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DocTokEnt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DocTokEnt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DocTokEnt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DocTokEnt::MergeFrom(const DocTokEnt& from) {
  GOOGLE_CHECK_NE(&from, this);
  tok_ids_.MergeFrom(from.tok_ids_);
  ent_begins_.MergeFrom(from.ent_begins_);
  ent_ends_.MergeFrom(from.ent_ends_);
  ent_ids_.MergeFrom(from.ent_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_docid()) {
      set_docid(from.docid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DocTokEnt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DocTokEnt::CopyFrom(const DocTokEnt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocTokEnt::IsInitialized() const {

  return true;
}

void DocTokEnt::Swap(DocTokEnt* other) {
  if (other != this) {
    std::swap(docid_, other->docid_);
    tok_ids_.Swap(&other->tok_ids_);
    ent_begins_.Swap(&other->ent_begins_);
    ent_ends_.Swap(&other->ent_ends_);
    ent_ids_.Swap(&other->ent_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DocTokEnt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DocTokEnt_descriptor_;
  metadata.reflection = DocTokEnt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TrainWork::kFocusTidFieldNumber;
const int TrainWork::kFocusKindFieldNumber;
const int TrainWork::kContextTidsFieldNumber;
const int TrainWork::kContextKindsFieldNumber;
#endif  // !_MSC_VER

TrainWork::TrainWork()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ncc.TrainWork)
}

void TrainWork::InitAsDefaultInstance() {
}

TrainWork::TrainWork(const TrainWork& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ncc.TrainWork)
}

void TrainWork::SharedCtor() {
  _cached_size_ = 0;
  focus_tid_ = 0;
  focus_kind_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrainWork::~TrainWork() {
  // @@protoc_insertion_point(destructor:ncc.TrainWork)
  SharedDtor();
}

void TrainWork::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TrainWork::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrainWork::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrainWork_descriptor_;
}

const TrainWork& TrainWork::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ncc_2eproto();
  return *default_instance_;
}

TrainWork* TrainWork::default_instance_ = NULL;

TrainWork* TrainWork::New() const {
  return new TrainWork;
}

void TrainWork::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TrainWork*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(focus_tid_, focus_kind_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  context_tids_.Clear();
  context_kinds_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TrainWork::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ncc.TrainWork)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 focus_tid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &focus_tid_)));
          set_has_focus_tid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_focus_kind;
        break;
      }

      // optional .ncc.TokenKind focus_kind = 2;
      case 2: {
        if (tag == 16) {
         parse_focus_kind:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ncc::TokenKind_IsValid(value)) {
            set_focus_kind(static_cast< ::ncc::TokenKind >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_context_tids;
        break;
      }

      // repeated int32 context_tids = 3 [packed = true];
      case 3: {
        if (tag == 26) {
         parse_context_tids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_context_tids())));
        } else if (tag == 24) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 26, input, this->mutable_context_tids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_context_kinds;
        break;
      }

      // repeated .ncc.TokenKind context_kinds = 4 [packed = true];
      case 4: {
        if (tag == 34) {
         parse_context_kinds:
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit = input->PushLimit(length);
          while (input->BytesUntilLimit() > 0) {
            int value;
            DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
            if (::ncc::TokenKind_IsValid(value)) {
              add_context_kinds(static_cast< ::ncc::TokenKind >(value));
            }
          }
          input->PopLimit(limit);
        } else if (tag == 32) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ncc::TokenKind_IsValid(value)) {
            add_context_kinds(static_cast< ::ncc::TokenKind >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ncc.TrainWork)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ncc.TrainWork)
  return false;
#undef DO_
}

void TrainWork::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ncc.TrainWork)
  // optional int32 focus_tid = 1;
  if (has_focus_tid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->focus_tid(), output);
  }

  // optional .ncc.TokenKind focus_kind = 2;
  if (has_focus_kind()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->focus_kind(), output);
  }

  // repeated int32 context_tids = 3 [packed = true];
  if (this->context_tids_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_context_tids_cached_byte_size_);
  }
  for (int i = 0; i < this->context_tids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->context_tids(i), output);
  }

  // repeated .ncc.TokenKind context_kinds = 4 [packed = true];
  if (this->context_kinds_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      output);
    output->WriteVarint32(_context_kinds_cached_byte_size_);
  }
  for (int i = 0; i < this->context_kinds_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnumNoTag(
      this->context_kinds(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ncc.TrainWork)
}

::google::protobuf::uint8* TrainWork::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ncc.TrainWork)
  // optional int32 focus_tid = 1;
  if (has_focus_tid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->focus_tid(), target);
  }

  // optional .ncc.TokenKind focus_kind = 2;
  if (has_focus_kind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->focus_kind(), target);
  }

  // repeated int32 context_tids = 3 [packed = true];
  if (this->context_tids_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _context_tids_cached_byte_size_, target);
  }
  for (int i = 0; i < this->context_tids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->context_tids(i), target);
  }

  // repeated .ncc.TokenKind context_kinds = 4 [packed = true];
  if (this->context_kinds_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(    _context_kinds_cached_byte_size_, target);
  }
  for (int i = 0; i < this->context_kinds_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumNoTagToArray(
      this->context_kinds(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ncc.TrainWork)
  return target;
}

int TrainWork::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 focus_tid = 1;
    if (has_focus_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->focus_tid());
    }

    // optional .ncc.TokenKind focus_kind = 2;
    if (has_focus_kind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->focus_kind());
    }

  }
  // repeated int32 context_tids = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->context_tids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->context_tids(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _context_tids_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .ncc.TokenKind context_kinds = 4 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->context_kinds_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->context_kinds(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _context_kinds_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrainWork::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TrainWork* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TrainWork*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TrainWork::MergeFrom(const TrainWork& from) {
  GOOGLE_CHECK_NE(&from, this);
  context_tids_.MergeFrom(from.context_tids_);
  context_kinds_.MergeFrom(from.context_kinds_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_focus_tid()) {
      set_focus_tid(from.focus_tid());
    }
    if (from.has_focus_kind()) {
      set_focus_kind(from.focus_kind());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TrainWork::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrainWork::CopyFrom(const TrainWork& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrainWork::IsInitialized() const {

  return true;
}

void TrainWork::Swap(TrainWork* other) {
  if (other != this) {
    std::swap(focus_tid_, other->focus_tid_);
    std::swap(focus_kind_, other->focus_kind_);
    context_tids_.Swap(&other->context_tids_);
    context_kinds_.Swap(&other->context_kinds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TrainWork::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrainWork_descriptor_;
  metadata.reflection = TrainWork_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PhraseInstance::kThLabelFieldNumber;
const int PhraseInstance::kNoncompLabelFieldNumber;
const int PhraseInstance::kPhraseWidFieldNumber;
const int PhraseInstance::kWordWidsFieldNumber;
#endif  // !_MSC_VER

PhraseInstance::PhraseInstance()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ncc.PhraseInstance)
}

void PhraseInstance::InitAsDefaultInstance() {
}

PhraseInstance::PhraseInstance(const PhraseInstance& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ncc.PhraseInstance)
}

void PhraseInstance::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  th_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  noncomp_label_ = 0;
  phrase_wid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PhraseInstance::~PhraseInstance() {
  // @@protoc_insertion_point(destructor:ncc.PhraseInstance)
  SharedDtor();
}

void PhraseInstance::SharedDtor() {
  if (th_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete th_label_;
  }
  if (this != default_instance_) {
  }
}

void PhraseInstance::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PhraseInstance::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PhraseInstance_descriptor_;
}

const PhraseInstance& PhraseInstance::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ncc_2eproto();
  return *default_instance_;
}

PhraseInstance* PhraseInstance::default_instance_ = NULL;

PhraseInstance* PhraseInstance::New() const {
  return new PhraseInstance;
}

void PhraseInstance::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PhraseInstance*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(noncomp_label_, phrase_wid_);
    if (has_th_label()) {
      if (th_label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        th_label_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  word_wids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PhraseInstance::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ncc.PhraseInstance)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string th_label = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_th_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->th_label().data(), this->th_label().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "th_label");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_noncomp_label;
        break;
      }

      // optional float noncomp_label = 2;
      case 2: {
        if (tag == 21) {
         parse_noncomp_label:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &noncomp_label_)));
          set_has_noncomp_label();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_phrase_wid;
        break;
      }

      // optional int32 phrase_wid = 3;
      case 3: {
        if (tag == 24) {
         parse_phrase_wid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &phrase_wid_)));
          set_has_phrase_wid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_word_wids;
        break;
      }

      // repeated int32 word_wids = 4;
      case 4: {
        if (tag == 32) {
         parse_word_wids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_word_wids())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_word_wids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_word_wids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ncc.PhraseInstance)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ncc.PhraseInstance)
  return false;
#undef DO_
}

void PhraseInstance::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ncc.PhraseInstance)
  // optional string th_label = 1;
  if (has_th_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->th_label().data(), this->th_label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "th_label");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->th_label(), output);
  }

  // optional float noncomp_label = 2;
  if (has_noncomp_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->noncomp_label(), output);
  }

  // optional int32 phrase_wid = 3;
  if (has_phrase_wid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->phrase_wid(), output);
  }

  // repeated int32 word_wids = 4;
  for (int i = 0; i < this->word_wids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->word_wids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ncc.PhraseInstance)
}

::google::protobuf::uint8* PhraseInstance::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ncc.PhraseInstance)
  // optional string th_label = 1;
  if (has_th_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->th_label().data(), this->th_label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "th_label");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->th_label(), target);
  }

  // optional float noncomp_label = 2;
  if (has_noncomp_label()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->noncomp_label(), target);
  }

  // optional int32 phrase_wid = 3;
  if (has_phrase_wid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->phrase_wid(), target);
  }

  // repeated int32 word_wids = 4;
  for (int i = 0; i < this->word_wids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->word_wids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ncc.PhraseInstance)
  return target;
}

int PhraseInstance::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string th_label = 1;
    if (has_th_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->th_label());
    }

    // optional float noncomp_label = 2;
    if (has_noncomp_label()) {
      total_size += 1 + 4;
    }

    // optional int32 phrase_wid = 3;
    if (has_phrase_wid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->phrase_wid());
    }

  }
  // repeated int32 word_wids = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->word_wids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->word_wids(i));
    }
    total_size += 1 * this->word_wids_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PhraseInstance::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PhraseInstance* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PhraseInstance*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PhraseInstance::MergeFrom(const PhraseInstance& from) {
  GOOGLE_CHECK_NE(&from, this);
  word_wids_.MergeFrom(from.word_wids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_th_label()) {
      set_th_label(from.th_label());
    }
    if (from.has_noncomp_label()) {
      set_noncomp_label(from.noncomp_label());
    }
    if (from.has_phrase_wid()) {
      set_phrase_wid(from.phrase_wid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PhraseInstance::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PhraseInstance::CopyFrom(const PhraseInstance& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhraseInstance::IsInitialized() const {

  return true;
}

void PhraseInstance::Swap(PhraseInstance* other) {
  if (other != this) {
    std::swap(th_label_, other->th_label_);
    std::swap(noncomp_label_, other->noncomp_label_);
    std::swap(phrase_wid_, other->phrase_wid_);
    word_wids_.Swap(&other->word_wids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PhraseInstance::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PhraseInstance_descriptor_;
  metadata.reflection = PhraseInstance_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Config::kUnipowerFieldNumber;
const int Config::kDimFieldNumber;
const int Config::kWindowFieldNumber;
const int Config::kNegFieldNumber;
const int Config::kStepFieldNumber;
const int Config::kEpochsFieldNumber;
const int Config::kSlotsFieldNumber;
const int Config::kDebugFieldNumber;
#endif  // !_MSC_VER

Config::Config()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ncc.Config)
}

void Config::InitAsDefaultInstance() {
}

Config::Config(const Config& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ncc.Config)
}

void Config::SharedCtor() {
  _cached_size_ = 0;
  unipower_ = 0.75f;
  dim_ = 100;
  window_ = 5;
  neg_ = 5;
  step_ = 0.025f;
  epochs_ = 1;
  slots_ = 100000000;
  debug_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Config::~Config() {
  // @@protoc_insertion_point(destructor:ncc.Config)
  SharedDtor();
}

void Config::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Config::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Config::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Config_descriptor_;
}

const Config& Config::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ncc_2eproto();
  return *default_instance_;
}

Config* Config::default_instance_ = NULL;

Config* Config::New() const {
  return new Config;
}

void Config::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    unipower_ = 0.75f;
    dim_ = 100;
    window_ = 5;
    neg_ = 5;
    step_ = 0.025f;
    epochs_ = 1;
    slots_ = 100000000;
    debug_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Config::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ncc.Config)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float unipower = 1 [default = 0.75];
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &unipower_)));
          set_has_unipower();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_dim;
        break;
      }

      // required int32 dim = 2 [default = 100];
      case 2: {
        if (tag == 16) {
         parse_dim:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dim_)));
          set_has_dim();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_window;
        break;
      }

      // required int32 window = 3 [default = 5];
      case 3: {
        if (tag == 24) {
         parse_window:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &window_)));
          set_has_window();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_neg;
        break;
      }

      // required int32 neg = 4 [default = 5];
      case 4: {
        if (tag == 32) {
         parse_neg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &neg_)));
          set_has_neg();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_step;
        break;
      }

      // required float step = 5 [default = 0.025];
      case 5: {
        if (tag == 45) {
         parse_step:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &step_)));
          set_has_step();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_epochs;
        break;
      }

      // required int32 epochs = 6 [default = 1];
      case 6: {
        if (tag == 48) {
         parse_epochs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &epochs_)));
          set_has_epochs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_slots;
        break;
      }

      // required int32 slots = 7 [default = 100000000];
      case 7: {
        if (tag == 56) {
         parse_slots:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &slots_)));
          set_has_slots();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(7992)) goto parse_debug;
        break;
      }

      // required int32 debug = 999 [default = 0];
      case 999: {
        if (tag == 7992) {
         parse_debug:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &debug_)));
          set_has_debug();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ncc.Config)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ncc.Config)
  return false;
#undef DO_
}

void Config::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ncc.Config)
  // required float unipower = 1 [default = 0.75];
  if (has_unipower()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->unipower(), output);
  }

  // required int32 dim = 2 [default = 100];
  if (has_dim()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->dim(), output);
  }

  // required int32 window = 3 [default = 5];
  if (has_window()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->window(), output);
  }

  // required int32 neg = 4 [default = 5];
  if (has_neg()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->neg(), output);
  }

  // required float step = 5 [default = 0.025];
  if (has_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->step(), output);
  }

  // required int32 epochs = 6 [default = 1];
  if (has_epochs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->epochs(), output);
  }

  // required int32 slots = 7 [default = 100000000];
  if (has_slots()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->slots(), output);
  }

  // required int32 debug = 999 [default = 0];
  if (has_debug()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(999, this->debug(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ncc.Config)
}

::google::protobuf::uint8* Config::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ncc.Config)
  // required float unipower = 1 [default = 0.75];
  if (has_unipower()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->unipower(), target);
  }

  // required int32 dim = 2 [default = 100];
  if (has_dim()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->dim(), target);
  }

  // required int32 window = 3 [default = 5];
  if (has_window()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->window(), target);
  }

  // required int32 neg = 4 [default = 5];
  if (has_neg()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->neg(), target);
  }

  // required float step = 5 [default = 0.025];
  if (has_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->step(), target);
  }

  // required int32 epochs = 6 [default = 1];
  if (has_epochs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->epochs(), target);
  }

  // required int32 slots = 7 [default = 100000000];
  if (has_slots()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->slots(), target);
  }

  // required int32 debug = 999 [default = 0];
  if (has_debug()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(999, this->debug(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ncc.Config)
  return target;
}

int Config::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float unipower = 1 [default = 0.75];
    if (has_unipower()) {
      total_size += 1 + 4;
    }

    // required int32 dim = 2 [default = 100];
    if (has_dim()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->dim());
    }

    // required int32 window = 3 [default = 5];
    if (has_window()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->window());
    }

    // required int32 neg = 4 [default = 5];
    if (has_neg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->neg());
    }

    // required float step = 5 [default = 0.025];
    if (has_step()) {
      total_size += 1 + 4;
    }

    // required int32 epochs = 6 [default = 1];
    if (has_epochs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->epochs());
    }

    // required int32 slots = 7 [default = 100000000];
    if (has_slots()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->slots());
    }

    // required int32 debug = 999 [default = 0];
    if (has_debug()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->debug());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Config::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Config* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Config*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Config::MergeFrom(const Config& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unipower()) {
      set_unipower(from.unipower());
    }
    if (from.has_dim()) {
      set_dim(from.dim());
    }
    if (from.has_window()) {
      set_window(from.window());
    }
    if (from.has_neg()) {
      set_neg(from.neg());
    }
    if (from.has_step()) {
      set_step(from.step());
    }
    if (from.has_epochs()) {
      set_epochs(from.epochs());
    }
    if (from.has_slots()) {
      set_slots(from.slots());
    }
    if (from.has_debug()) {
      set_debug(from.debug());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Config::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Config::CopyFrom(const Config& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void Config::Swap(Config* other) {
  if (other != this) {
    std::swap(unipower_, other->unipower_);
    std::swap(dim_, other->dim_);
    std::swap(window_, other->window_);
    std::swap(neg_, other->neg_);
    std::swap(step_, other->step_);
    std::swap(epochs_, other->epochs_);
    std::swap(slots_, other->slots_);
    std::swap(debug_, other->debug_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Config::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Config_descriptor_;
  metadata.reflection = Config_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModelParts::kRadiusFieldNumber;
#endif  // !_MSC_VER

ModelParts::ModelParts()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ncc.ModelParts)
}

void ModelParts::InitAsDefaultInstance() {
}

ModelParts::ModelParts(const ModelParts& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ncc.ModelParts)
}

void ModelParts::SharedCtor() {
  _cached_size_ = 0;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelParts::~ModelParts() {
  // @@protoc_insertion_point(destructor:ncc.ModelParts)
  SharedDtor();
}

void ModelParts::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModelParts::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelParts::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelParts_descriptor_;
}

const ModelParts& ModelParts::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ncc_2eproto();
  return *default_instance_;
}

ModelParts* ModelParts::default_instance_ = NULL;

ModelParts* ModelParts::New() const {
  return new ModelParts;
}

void ModelParts::Clear() {
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModelParts::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ncc.ModelParts)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float radius = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ncc.ModelParts)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ncc.ModelParts)
  return false;
#undef DO_
}

void ModelParts::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ncc.ModelParts)
  // optional float radius = 1;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ncc.ModelParts)
}

::google::protobuf::uint8* ModelParts::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ncc.ModelParts)
  // optional float radius = 1;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ncc.ModelParts)
  return target;
}

int ModelParts::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float radius = 1;
    if (has_radius()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelParts::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModelParts* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModelParts*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModelParts::MergeFrom(const ModelParts& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModelParts::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelParts::CopyFrom(const ModelParts& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelParts::IsInitialized() const {

  return true;
}

void ModelParts::Swap(ModelParts* other) {
  if (other != this) {
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModelParts::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelParts_descriptor_;
  metadata.reflection = ModelParts_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ncc

// @@protoc_insertion_point(global_scope)
